#include "abox.h"

#define ABOXTIMEOUT (5*RT_TICK_PER_SECOND)  //5 seconds at a time
#define SERTIMEOUT  (60*RT_TICK_PER_SECOND) //超时设置



	/* get data */
#ifdef VAR_MQ	
	//var_mq_t aboxMqInfo[ABOX_MQ_NUM];
#else
	Message_Queue_Info aboxMqInfo[ABOX_MQ_NUM];
#endif	




typedef struct _set_timer_info
{
	rt_tick_t tick_pri;
	rt_tick_t timeout;
}set_timer_info;




/**
 * This function will show the existing Cbox information in Abox.
 *
 * @param void
 * @return void
 *
 */	
void listReport()
{
	at_print_open();

	rt_uint8_t index = 0;
	cbox_assessment_report cboxReportTemp;
	at_printf("\r\n/******** listReport ***********/\r\n");
	for(index = 0;index<aboxInfo.cboxTotalInfo.cboxOnlineNum;index++)
	{
		cboxReportTemp = aboxInfo.cboxTotalInfo.cboxInfo[index].cboxAssessReport;
	    at_printf("boxID : %d\r\n",aboxInfo.cboxTotalInfo.cboxInfo[index].devidCollection[0]&0xffffff);
		at_printf("send packNum: %d\r\n",cboxReportTemp.packTotal);
		at_printf("err  packNum: %d\r\n",cboxReportTemp.packErr);
		at_printf("\r\n");
	}
	at_printf("\r\n/******** end ***********/\r\n");
	
	at_print_close();


}


/**
 * This function will Process five yards of data for Abox.
 *
 * @param send        : the buff will be send.
 * @param len         : the length of valid data in the send buffer.
 * @param event_type  : the urgency of the message 
 *
 * @return void
 *
 */	
int Abox_send_pack(char *send, rt_uint16_t len,int eventType)//len = packcmd + data length
{
	if(RT_NULL == send) 	return RT_ERROR;

	rt_uint16_t 			crc;
							
	crc = ModbusCrc16((rt_uint8_t *)send, len);
	send[len + 0] =  crc & 0xff;
	send[len + 1] = (crc & 0xff00) >> 8;				
	crc = len + 2;    
	sendDataToServer(SEND_DATA,(rt_uint8_t *)send,crc);
	
	return RT_EOK;			
}







/**
 * This function will process data from server.
 *
 * @param addDtaInfo_t recving information.
 *
 * @return void
 *
 */
void recvServerData(rt_uint8_t *recv)
{
	if(!recv) return;	
	if(!aboxInfo.cboxTotalInfo.cboxOnlineNum) return;
	
	stPackCmd *packcmd= (stPackCmd	*)recv; 
	rt_uint32_t i = 0;
	rt_uint8_t  entryNum  = 0;
	uint16_t recvLen = sizeof(stPackCmd)+packcmd->len+2;

	at_printf("recvLen = %d \r\n",recvLen);

	for(i=0; i<aboxInfo.cboxTotalInfo.cboxOnlineNum; i++)
	{
		/* check modid */
		if(packcmd->id == (aboxInfo.cboxTotalInfo.cboxInfo[i].devidCollection[CBOX_DEVID] & 0x00ffffff) )	
		{
			entryNum = aboxInfo.cboxTotalInfo.cboxInfo[i].cboxDataInfo.entryNum;
		
			/* check data number allow */
			if(entryNum < CBOX_MAX_DATA_LIST)
			{
			
				/* check save ok */
				aboxInfo.cboxTotalInfo.cboxInfo[i].cboxDataInfo.cboxDataList[entryNum].dataAddr 
					= WritePool(aboxInfo.cboxDataPool,recv,recvLen);

				if(aboxInfo.cboxTotalInfo.cboxInfo[i].cboxDataInfo.cboxDataList[entryNum].dataAddr >= 0)
				{					
					aboxInfo.cboxTotalInfo.cboxInfo[i].cboxDataInfo.cboxDataList[entryNum].dataLength = recvLen;
					aboxInfo.cboxTotalInfo.cboxInfo[i].cboxDataInfo.entryNum++;
				}
				else
				{
					at_printf("get data is err!\r\n");
					//aboxInfo.cboxTotalInfo.cboxInfo[i].cboxDataInfo.cboxDataList[entryNum-1].dataAddr = 0;	
				}

			}
			
			break;
		}
		

	}
	

}



/**
 * Receive server registration information for Abox.
 *
 * @param dev_type : current device type.		
 * @param rev : the received buff 
 *
 * @return void
 *
 */	
void Abox_DEV_USER_GET_SSTATUS(char *rev)    //cmd 19
{
	if(!rev) return;
	
	TCMD_19_Info cmd_19_info;
	rt_memcpy(&cmd_19_info, rev + sizeof(stPackCmd), sizeof(cmd_19_info));


	/* panel registration information */

	switch(cmd_19_info.status)
	{
		case 0:  //no
			Cdma_Info.link = CONNECT_AT;
			break;
		case 1: //yes
			Cdma_Info.link = CONNECT_SERVER;
			break;


		default:
			break;
	}
		
    at_printf("19  cmd  is get！cmd_162_info.sreg  = %d  !\r\n",cmd_19_info.status );	



}






/**
 * this function will package a heartbeat for server.
 *
 * @param sendbuf: send buff
 *
 * @return void
 *
 */ 
void pack_ser_heart(rt_uint8_t *sendbuf)
{
	rt_uint16_t crc;
	
	if(RT_NULL != sendbuf)
	{
		rt_memset(sendbuf,0,BUFF_LEN);
		
		stPackCmd packcmd;
		rt_uint8_t i = 0;

		/* packcmd */
		packcmd.soh = CSOH;	 
		packcmd.cmd   = TCMD_1;
		packcmd.id		= Sys_Setup.app.id; 
		packcmd.len = aboxInfo.cboxTotalInfo.cboxOnlineNum* 4;
		rt_memcpy(sendbuf,&packcmd,sizeof(packcmd));

		cbox_information  *cboxInfo_t = &aboxInfo.cboxTotalInfo.cboxInfo[0];

		/* data copy */
		for(i=0;i<aboxInfo.cboxTotalInfo.cboxOnlineNum;i++)
		{
			//at_printf("cbox[%d]= %d\r\n",i,cboxInfo_t->devidCollection[CBOX_DEVID]&0xffffff);
			rt_memcpy(sendbuf+sizeof(packcmd)+4*i,&cboxInfo_t->devidCollection[CBOX_DEVID],4);	
			cboxInfo_t++;
		}
	
		crc = ModbusCrc16(sendbuf, sizeof(stPackCmd)+packcmd.len);
		rt_memcpy(sendbuf+sizeof(stPackCmd)+packcmd.len,&crc,2);


		/* copy heart data */					
		sendDataToServer(SEND_DATA, sendbuf,sizeof(stPackCmd)+packcmd.len+2);
	}

}



/**
 * Send registration information.
 *
 * @param void
 *
 * @return void
 *
 */
static void ser_reg(rt_uint8_t *buf)
{
	 
	if(netif_list->flags & NETIF_FLAG_LINK_UP)
	{
		if(Cdma_Info.link == CONNECT_AT)
		{
			at_printf("send reg!\r\n");
			sub_PackRegCmd(buf);	
		}
	}

}

/**
 * Send registration information.
 *
 * @param void
 *
 * @return void
 *
 */
void ser_heart()
{
	rt_uint8_t temp[BUFF_LEN];
	if(netif_list->flags & NETIF_FLAG_LINK_UP)
	{
		if(Panel_con_eth == dicInfo.secondDicInfo.panelLink)
		{
				at_printf("send heart!\r\n");
				pack_ser_heart(temp);
		}

	}
}



/**
 * it is start timer for Abox.
 *
 * @param void
 *
 * @return void
 *
 */
void setAboxTimerInfo(set_timer_info *timerInfo_t)
{
	timerInfo_t->tick_pri = rt_tick_get();
	timerInfo_t->timeout  = ABOXTIMEOUT;
}

void processTimer(rt_uint8_t *buf)
{
	static rt_uint8_t times = 0;

	times++;
	ser_reg(buf);
	
	if(!(times%3))  ser_heart();
		
}

/**
 * it is used to process data from Abox exchange.
 * Receive data from the server (Ethernet), process data from Cbox (sub-g).
 *
 * @param void
 *
 * @return void
 *
 */
void Abox_thread_entry(void* parameter)
{
	set_timer_info timerInfo;
	static rt_uint8_t ex_buf[BUFF_LEN];
	setAboxTimerInfo(&timerInfo);


	while(1)
	{
		rt_memset(ex_buf,0,sizeof(ex_buf));
			
		if(RT_EOK == mq_recv(A_STOA_MQ,ex_buf, sizeof(ex_buf),timerInfo.timeout))
		{
			//at_printf("recv serpack \r\n");
			cdma_rev_pack(ex_buf,A_STOA_MQ);
		}
		
		if((rt_tick_get()-timerInfo.tick_pri) > timerInfo.timeout)
		{
			processTimer(ex_buf);
			setAboxTimerInfo(&timerInfo);
		}	

#if 1
		if((Cdma_Info.serHeartTime > rt_tick_get()) 
			|| (AT_UPDATA == Cdma_Info.AT_status)
			|| (Panel_con_eth != dicInfo.secondDicInfo.panelLink))
		{
			Cdma_Info.serHeartTime = rt_tick_get();
		}
		else
		{
			/* 当出现需要重启lwip的时候           需要重启设备再次开启lwip */
			if( (Panel_con_eth == dicInfo.secondDicInfo.panelLink) 
				&& ((rt_tick_get()-Cdma_Info.serHeartTime) > SERTIMEOUT))
			{	
				rt_kprintf("server heart timeout!\r\n");
				//cmd_reboot();		
				quitTcpConnect();
			}
				
		}
#endif		

	}	

}



void Led_box_thread_entry(void* parameter)
{
	int i = 0;
	while(1)
	{
		rt_thread_delay(1000);
		if(!aboxInfo.cboxTotalInfo.cboxOnlineNum)
		{
				OutputLed(LEDON, LED_BOX);	
		}
		else
		{
			for(i=0;i<aboxInfo.cboxTotalInfo.cboxOnlineNum;i++)
			{
				OutputLed(LEDON, LED_BOX);
				rt_thread_delay(200);
				OutputLed(LEDOFF,LED_BOX);
				rt_thread_delay(200);
			}
		}
	}
	
}

void Led_roof_thread_entry(void* parameter)
{
	while(1)
	{
		if(!(aboxInfo.packageInfo.packageSendNum % 200))
		{
			OutputLed(LEDON, LED_ROOF);
			rt_thread_delay(100);
		}
		else
		{
			OutputLed(LEDOFF, LED_ROOF);
			rt_thread_delay(5);
		}
			
	}
	
}


/**
 * this function will initialize the main function, which is used primarily 
 * for the data interaction between the panel and the server,and it works for Abox's program.
 *
 * @param void
 *
 * @return void
 *
 */
void exchange_Abox_init(void)
{
	//	  rt_err_t  	init_thread;
	  rt_thread_t exchange_thread; //

	  exchange_thread = rt_thread_create("Abox_ex",
							  Abox_thread_entry, RT_NULL,
							  1024*2,AOX_EX_PRI, 20);


	  if (exchange_thread != RT_NULL)
      rt_thread_startup(exchange_thread);


	  rt_thread_t ledbox_thread; //

	  ledbox_thread = rt_thread_create("ledbox_ex",
							  Led_box_thread_entry, RT_NULL,
							  256,LED_SET_PRI, 20);


	  if (ledbox_thread != RT_NULL)
      rt_thread_startup(ledbox_thread);

	  rt_thread_t ledRoof_thread; //
	  ledRoof_thread = rt_thread_create("ledbRoof_ex",
							  Led_roof_thread_entry, RT_NULL,
							  256,LED_SET_PRI, 20);


	  if (ledRoof_thread != RT_NULL)
      rt_thread_startup(ledRoof_thread );
	

//      return 0;			
		
}



